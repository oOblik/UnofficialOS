# SPDX-License-Identifier: GPL-2.0-or-later
# Copyright (C) 2023-present BrooksyTech (https://github.com/brooksytech)

diff -rupN linux.orig/drivers/input/Kconfig linux/drivers/input/Kconfig
--- linux.orig/drivers/input/Kconfig	2022-11-01 17:55:27.002485730 -0400
+++ linux/drivers/input/Kconfig	2022-11-01 17:56:17.140793505 -0400
@@ -51,6 +51,19 @@ config INPUT_FF_MEMLESS
 	  To compile this driver as a module, choose M here: the
 	  module will be called ff-memless.
 
+config INPUT_POLLDEV
+	tristate "Polled input device skeleton"
+	help
+	  Say Y here if you are using a driver for an input
+	  device that periodically polls hardware state. This
+	  option is only useful for out-of-tree drivers since
+	  in-tree drivers select it automatically.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called input-polldev.
+
 config INPUT_SPARSEKMAP
 	tristate "Sparse keymap support library"
 	help
diff -rupN linux.orig/drivers/input/Makefile linux/drivers/input/Makefile
--- linux.orig/drivers/input/Makefile	2022-11-01 17:55:27.002485730 -0400
+++ linux/drivers/input/Makefile	2022-11-01 17:56:17.140793505 -0400
@@ -10,6 +10,7 @@ input-core-y := input.o input-compat.o i
 input-core-y += touchscreen.o
 
 obj-$(CONFIG_INPUT_FF_MEMLESS)	+= ff-memless.o
+obj-$(CONFIG_INPUT_POLLDEV)	+= input-polldev.o
 obj-$(CONFIG_INPUT_SPARSEKMAP)	+= sparse-keymap.o
 obj-$(CONFIG_INPUT_MATRIXKMAP)	+= matrix-keymap.o
 obj-$(CONFIG_INPUT_VIVALDIFMAP)	+= vivaldi-fmap.o
diff -rupN linux.orig/include/linux/input-polldev.h linux/include/linux/input-polldev.h
--- linux.orig/include/linux/input-polldev.h	1969-12-31 19:00:00.000000000 -0500
+++ linux/include/linux/input-polldev.h	2022-11-01 17:56:17.144793376 -0400
@@ -0,0 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+#ifndef _INPUT_POLLDEV_H
+#define _INPUT_POLLDEV_H
+
+/*
+ * Copyright (c) 2007 Dmitry Torokhov
+ */
+
+#include <linux/input.h>
+#include <linux/workqueue.h>
+
+/**
+ * struct input_polled_dev - simple polled input device
+ * @private: private driver data.
+ * @open: driver-supplied method that prepares device for polling
+ *	(enabled the device and maybe flushes device state).
+ * @close: driver-supplied method that is called when device is no
+ *	longer being polled. Used to put device into low power mode.
+ * @poll: driver-supplied method that polls the device and posts
+ *	input events (mandatory).
+ * @poll_interval: specifies how often the poll() method should be called.
+ *	Defaults to 500 msec unless overridden when registering the device.
+ * @poll_interval_max: specifies upper bound for the poll interval.
+ *	Defaults to the initial value of @poll_interval.
+ * @poll_interval_min: specifies lower bound for the poll interval.
+ *	Defaults to 0.
+ * @input: input device structure associated with the polled device.
+ *	Must be properly initialized by the driver (id, name, phys, bits).
+ *
+ * Polled input device provides a skeleton for supporting simple input
+ * devices that do not raise interrupts but have to be periodically
+ * scanned or polled to detect changes in their state.
+ */
+struct input_polled_dev {
+	void *private;
+
+	void (*open)(struct input_polled_dev *dev);
+	void (*close)(struct input_polled_dev *dev);
+	void (*poll)(struct input_polled_dev *dev);
+	unsigned int poll_interval; /* msec */
+	unsigned int poll_interval_max; /* msec */
+	unsigned int poll_interval_min; /* msec */
+
+	struct input_dev *input;
+
+/* private: */
+	struct delayed_work work;
+
+	bool devres_managed;
+};
+
+struct input_polled_dev *input_allocate_polled_device(void);
+struct input_polled_dev *devm_input_allocate_polled_device(struct device *dev);
+void input_free_polled_device(struct input_polled_dev *dev);
+int input_register_polled_device(struct input_polled_dev *dev);
+void input_unregister_polled_device(struct input_polled_dev *dev);
+
+#endif
diff -rupN linux.orig/drivers/input/input-polldev.c linux/drivers/input/input-polldev.c
--- linux.orig/drivers/input/input-polldev.c	1969-12-31 19:00:00.000000000 -0500
+++ linux/drivers/input/input-polldev.c	2022-11-01 17:56:17.140793505 -0400
@@ -0,0 +1,362 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Generic implementation of a polled input device
+
+ * Copyright (c) 2007 Dmitry Torokhov
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/input-polldev.h>
+
+MODULE_AUTHOR("Dmitry Torokhov <dtor@mail.ru>");
+MODULE_DESCRIPTION("Generic implementation of a polled input device");
+MODULE_LICENSE("GPL v2");
+
+static void input_polldev_queue_work(struct input_polled_dev *dev)
+{
+	unsigned long delay;
+
+	delay = msecs_to_jiffies(dev->poll_interval);
+	if (delay >= HZ)
+		delay = round_jiffies_relative(delay);
+
+	queue_delayed_work(system_freezable_wq, &dev->work, delay);
+}
+
+static void input_polled_device_work(struct work_struct *work)
+{
+	struct input_polled_dev *dev =
+		container_of(work, struct input_polled_dev, work.work);
+
+	dev->poll(dev);
+	input_polldev_queue_work(dev);
+}
+
+static int input_open_polled_device(struct input_dev *input)
+{
+	struct input_polled_dev *dev = input_get_drvdata(input);
+
+	if (dev->open)
+		dev->open(dev);
+
+	/* Only start polling if polling is enabled */
+	if (dev->poll_interval > 0) {
+		dev->poll(dev);
+		input_polldev_queue_work(dev);
+	}
+
+	return 0;
+}
+
+static void input_close_polled_device(struct input_dev *input)
+{
+	struct input_polled_dev *dev = input_get_drvdata(input);
+
+	cancel_delayed_work_sync(&dev->work);
+
+	if (dev->close)
+		dev->close(dev);
+}
+
+/* SYSFS interface */
+
+static ssize_t input_polldev_get_poll(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct input_polled_dev *polldev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", polldev->poll_interval);
+}
+
+static ssize_t input_polldev_set_poll(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct input_polled_dev *polldev = dev_get_drvdata(dev);
+	struct input_dev *input = polldev->input;
+	unsigned int interval;
+	int err;
+
+	err = kstrtouint(buf, 0, &interval);
+	if (err)
+		return err;
+
+	if (interval < polldev->poll_interval_min)
+		return -EINVAL;
+
+	if (interval > polldev->poll_interval_max)
+		return -EINVAL;
+
+	mutex_lock(&input->mutex);
+
+	polldev->poll_interval = interval;
+
+	if (input->users) {
+		cancel_delayed_work_sync(&polldev->work);
+		if (polldev->poll_interval > 0)
+			input_polldev_queue_work(polldev);
+	}
+
+	mutex_unlock(&input->mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(poll, S_IRUGO | S_IWUSR, input_polldev_get_poll,
+					    input_polldev_set_poll);
+
+
+static ssize_t input_polldev_get_max(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct input_polled_dev *polldev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", polldev->poll_interval_max);
+}
+
+static DEVICE_ATTR(max, S_IRUGO, input_polldev_get_max, NULL);
+
+static ssize_t input_polldev_get_min(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct input_polled_dev *polldev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", polldev->poll_interval_min);
+}
+
+static DEVICE_ATTR(min, S_IRUGO, input_polldev_get_min, NULL);
+
+static struct attribute *sysfs_attrs[] = {
+	&dev_attr_poll.attr,
+	&dev_attr_max.attr,
+	&dev_attr_min.attr,
+	NULL
+};
+
+static struct attribute_group input_polldev_attribute_group = {
+	.attrs = sysfs_attrs
+};
+
+static const struct attribute_group *input_polldev_attribute_groups[] = {
+	&input_polldev_attribute_group,
+	NULL
+};
+
+/**
+ * input_allocate_polled_device - allocate memory for polled device
+ *
+ * The function allocates memory for a polled device and also
+ * for an input device associated with this polled device.
+ */
+struct input_polled_dev *input_allocate_polled_device(void)
+{
+	struct input_polled_dev *dev;
+
+	dev = kzalloc(sizeof(struct input_polled_dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	dev->input = input_allocate_device();
+	if (!dev->input) {
+		kfree(dev);
+		return NULL;
+	}
+
+	return dev;
+}
+EXPORT_SYMBOL(input_allocate_polled_device);
+
+struct input_polled_devres {
+	struct input_polled_dev *polldev;
+};
+
+static int devm_input_polldev_match(struct device *dev, void *res, void *data)
+{
+	struct input_polled_devres *devres = res;
+
+	return devres->polldev == data;
+}
+
+static void devm_input_polldev_release(struct device *dev, void *res)
+{
+	struct input_polled_devres *devres = res;
+	struct input_polled_dev *polldev = devres->polldev;
+
+	dev_dbg(dev, "%s: dropping reference/freeing %s\n",
+		__func__, dev_name(&polldev->input->dev));
+
+	input_put_device(polldev->input);
+	kfree(polldev);
+}
+
+static void devm_input_polldev_unregister(struct device *dev, void *res)
+{
+	struct input_polled_devres *devres = res;
+	struct input_polled_dev *polldev = devres->polldev;
+
+	dev_dbg(dev, "%s: unregistering device %s\n",
+		__func__, dev_name(&polldev->input->dev));
+	input_unregister_device(polldev->input);
+
+	/*
+	 * Note that we are still holding extra reference to the input
+	 * device so it will stick around until devm_input_polldev_release()
+	 * is called.
+	 */
+}
+
+/**
+ * devm_input_allocate_polled_device - allocate managed polled device
+ * @dev: device owning the polled device being created
+ *
+ * Returns prepared &struct input_polled_dev or %NULL.
+ *
+ * Managed polled input devices do not need to be explicitly unregistered
+ * or freed as it will be done automatically when owner device unbinds
+ * from * its driver (or binding fails). Once such managed polled device
+ * is allocated, it is ready to be set up and registered in the same
+ * fashion as regular polled input devices (using
+ * input_register_polled_device() function).
+ *
+ * If you want to manually unregister and free such managed polled devices,
+ * it can be still done by calling input_unregister_polled_device() and
+ * input_free_polled_device(), although it is rarely needed.
+ *
+ * NOTE: the owner device is set up as parent of input device and users
+ * should not override it.
+ */
+struct input_polled_dev *devm_input_allocate_polled_device(struct device *dev)
+{
+	struct input_polled_dev *polldev;
+	struct input_polled_devres *devres;
+
+	devres = devres_alloc(devm_input_polldev_release, sizeof(*devres),
+			      GFP_KERNEL);
+	if (!devres)
+		return NULL;
+
+	polldev = input_allocate_polled_device();
+	if (!polldev) {
+		devres_free(devres);
+		return NULL;
+	}
+
+	polldev->input->dev.parent = dev;
+	polldev->devres_managed = true;
+
+	devres->polldev = polldev;
+	devres_add(dev, devres);
+
+	return polldev;
+}
+EXPORT_SYMBOL(devm_input_allocate_polled_device);
+
+/**
+ * input_free_polled_device - free memory allocated for polled device
+ * @dev: device to free
+ *
+ * The function frees memory allocated for polling device and drops
+ * reference to the associated input device.
+ */
+void input_free_polled_device(struct input_polled_dev *dev)
+{
+	if (dev) {
+		if (dev->devres_managed)
+			WARN_ON(devres_destroy(dev->input->dev.parent,
+						devm_input_polldev_release,
+						devm_input_polldev_match,
+						dev));
+		input_put_device(dev->input);
+		kfree(dev);
+	}
+}
+EXPORT_SYMBOL(input_free_polled_device);
+
+/**
+ * input_register_polled_device - register polled device
+ * @dev: device to register
+ *
+ * The function registers previously initialized polled input device
+ * with input layer. The device should be allocated with call to
+ * input_allocate_polled_device(). Callers should also set up poll()
+ * method and set up capabilities (id, name, phys, bits) of the
+ * corresponding input_dev structure.
+ */
+int input_register_polled_device(struct input_polled_dev *dev)
+{
+	struct input_polled_devres *devres = NULL;
+	struct input_dev *input = dev->input;
+	int error;
+
+	if (dev->devres_managed) {
+		devres = devres_alloc(devm_input_polldev_unregister,
+				      sizeof(*devres), GFP_KERNEL);
+		if (!devres)
+			return -ENOMEM;
+
+		devres->polldev = dev;
+	}
+
+	input_set_drvdata(input, dev);
+	INIT_DELAYED_WORK(&dev->work, input_polled_device_work);
+
+	if (!dev->poll_interval)
+		dev->poll_interval = 500;
+	if (!dev->poll_interval_max)
+		dev->poll_interval_max = dev->poll_interval;
+
+	input->open = input_open_polled_device;
+	input->close = input_close_polled_device;
+
+	input->dev.groups = input_polldev_attribute_groups;
+
+	error = input_register_device(input);
+	if (error) {
+		devres_free(devres);
+		return error;
+	}
+
+	/*
+	 * Take extra reference to the underlying input device so
+	 * that it survives call to input_unregister_polled_device()
+	 * and is deleted only after input_free_polled_device()
+	 * has been invoked. This is needed to ease task of freeing
+	 * sparse keymaps.
+	 */
+	input_get_device(input);
+
+	if (dev->devres_managed) {
+		dev_dbg(input->dev.parent, "%s: registering %s with devres.\n",
+			__func__, dev_name(&input->dev));
+		devres_add(input->dev.parent, devres);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(input_register_polled_device);
+
+/**
+ * input_unregister_polled_device - unregister polled device
+ * @dev: device to unregister
+ *
+ * The function unregisters previously registered polled input
+ * device from input layer. Polling is stopped and device is
+ * ready to be freed with call to input_free_polled_device().
+ */
+void input_unregister_polled_device(struct input_polled_dev *dev)
+{
+	if (dev->devres_managed)
+		WARN_ON(devres_destroy(dev->input->dev.parent,
+					devm_input_polldev_unregister,
+					devm_input_polldev_match,
+					dev));
+
+	input_unregister_device(dev->input);
+}
+EXPORT_SYMBOL(input_unregister_polled_device);
diff -rupN joystick.orig/amlogic-saradc.h joystick/amlogic-saradc.h
--- a/drivers/input/joystick/amlogic-saradc.h	1970-01-01 00:00:00.000000000 +0000
+++ b/drivers/input/joystick/amlogic-saradc.h	2023-03-27 16:15:42.161652569 +0000
@@ -0,0 +1,32 @@
+/*
+ * include/dt-bindings/iio/adc/amlogic-saradc.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _DT_BINDINGS_IIO_ADC_AMLOGIC_H
+#define _DT_BINDINGS_IIO_ADC_AMLOGIC_H
+
+#define SARADC_CH0      0
+#define SARADC_CH1      1
+#define SARADC_CH2      2
+#define SARADC_CH3      3
+#define SARADC_CH4      4
+#define SARADC_CH5      5
+#define SARADC_CH6      6
+#define SARADC_CH7      7
+
+#define SARADC_CH_NUM 8
+
+#endif
diff --git a/arch/arm64/boot/dts/amlogic/meson-g12b-odroid-go-ultra.dts b/arch/arm64/boot/dts/amlogic/meson-g12b-odroid-go-ultra.dts
index 6831dd7af175..89da65b800bb 100644
--- a/arch/arm64/boot/dts/amlogic/meson-g12b-odroid-go-ultra.dts
+++ b/arch/arm64/boot/dts/amlogic/meson-g12b-odroid-go-ultra.dts
@@ -46,52 +46,6 @@ framebuffer@3d800000 {
 		  <&clkc CLKID_MIPI_DSI_PHY>;
 	};
 
-	adc-joystick-left {
-		compatible = "adc-joystick";
-		io-channels = <&saradc 2>, <&saradc 3>;
-		poll-interval = <10>;
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		axis@0 {
-			reg = <0>;
-			linux,code = <ABS_Y>;
-			abs-range = <3150 950>;
-			abs-fuzz = <32>;
-			abs-flat = <64>;
-		};
-		axis@1 {
-			reg = <1>;
-			linux,code = <ABS_X>;
-			abs-range = <700 2900>;
-			abs-fuzz = <32>;
-			abs-flat = <64>;
-		};
-	};
-
-	adc-joystick-right {
-		compatible = "adc-joystick";
-		io-channels = <&saradc 0>, <&saradc 1>;
-		poll-interval = <10>;
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		axis@0 {
-			reg = <0>;
-			linux,code = <ABS_RY>;
-			abs-range = <3150 950>;
-			abs-fuzz = <32>;
-			abs-flat = <64>;
-		};
-		axis@1 {
-			reg = <1>;
-			linux,code = <ABS_RX>;
-			abs-range = <800 3000>;
-			abs-fuzz = <32>;
-			abs-flat = <64>;
-		};
-	};
-	
 	panel_backlight: backlight {
 		compatible = "pwm-backlight";
 		pwms = <&pwm_ef 1 40000 0>;
@@ -131,11 +85,10 @@ codec_clk: codec-clk {
 		#clock-cells = <0>;
 	};
 
-	gpio-keys-polled {
+	gpio_keys: volume-keys {
 		compatible = "gpio-keys-polled";
-		poll-interval = <10>;
-		pinctrl-0 = <&keypad_gpio_pins>;
-		pinctrl-names = "default";
+		poll-interval = <200>;
+		autorepeat;
 
 		volume-up-button {
 			label = "VOLUME-UP";
@@ -147,6 +100,37 @@ volume-down-button {
 			linux,code = <KEY_VOLUMEDOWN>;
 			gpios = <&gpio GPIOX_9 GPIO_ACTIVE_LOW>;
 		};
+	};
+
+    joypad: gou_joypad {
+       compatible = "odroidgou-joypad";
+		poll-interval = <10>;
+		pinctrl-0 = <&keypad_gpio_pins>;
+		pinctrl-names = "default";
+        status = "okay";
+		
+		joypad-name = "Microsoft X-Box 360 pad";
+		joypad-vendor = <0x045e>;
+		joypad-product = <0x028e>;
+		joypad-revision = <0x0000>;
+
+		/* Analog sticks */
+		io-channels = <&saradc 0>, <&saradc 1>, <&saradc 2>, <&saradc 3>;
+		io-channel-names = "key-RY", "key-RX", "key-LY", "key-LX";
+		button-adc-scale = <4>;
+		button-adc-deadzone = <64>;
+		button-adc-fuzz = <32>;
+		button-adc-flat = <32>;
+		abs_x-p-tuning = <350>;
+		abs_x-n-tuning = <350>;
+		abs_y-p-tuning = <350>;
+		abs_y-n-tuning = <350>;
+		abs_rx-p-tuning = <350>;
+		abs_rx-n-tuning = <350>;
+		abs_ry-p-tuning = <350>;
+		abs_ry-n-tuning = <350>;
+
+		/* Buttons */
 		dpad-up-button {
 			label = "DPAD-UP";
 			linux,code = <BTN_DPAD_UP>;
@@ -187,53 +171,43 @@ x-button {
 			linux,code = <BTN_NORTH>;
 			gpios = <&gpio GPIOX_7 GPIO_ACTIVE_LOW>;
 		};
-		f1-button {
-			label = "F1";
-			linux,code = <BTN_TRIGGER_HAPPY1>;
-			gpios = <&gpio GPIOX_17 GPIO_ACTIVE_LOW>;
+		start-button {
+			label = "Start";
+			linux,code = <BTN_START>;
+			gpios = <&gpio GPIOX_16 GPIO_ACTIVE_LOW>;
 		};
-		f2-button {
-			label = "F2";
-			linux,code = <BTN_TRIGGER_HAPPY2>;
-			gpios = <&gpio GPIOX_10 GPIO_ACTIVE_LOW>;
+		select-button {
+			label = "Select";
+			linux,code = <BTN_SELECT>;
+			gpios = <&gpio GPIOX_17 GPIO_ACTIVE_LOW>;
 		};
-		f3-button {
-			label = "F3";
-			linux,code = <BTN_TRIGGER_HAPPY3>;
+		thumb-left-button {
+			label = "Thumb Left";
+			linux,code = <BTN_THUMBL>;
 			gpios = <&gpio GPIOX_11 GPIO_ACTIVE_LOW>;
 		};
-		f4-button {
-			label = "F4";
-			linux,code = <BTN_TRIGGER_HAPPY4>;
+		thumb-right-button {
+			label = "Thumb Right";
+			linux,code = <BTN_THUMBR>;
 			gpios = <&gpio GPIOX_12 GPIO_ACTIVE_LOW>;
 		};
-		f5-button {
-			label = "F5";
-			linux,code = <BTN_TRIGGER_HAPPY5>;
-			gpios = <&gpio GPIOX_13 GPIO_ACTIVE_LOW>;
-		};
-		f6-button {
-			label = "F6";
-			linux,code = <BTN_TRIGGER_HAPPY6>;
-			gpios = <&gpio GPIOX_16 GPIO_ACTIVE_LOW>;
-		};
 		top-left-button {
-			label = "TOP Left";
+			label = "Top Left";
 			linux,code = <BTN_TL>;
 			gpios = <&gpio GPIOX_14 GPIO_ACTIVE_LOW>;
 		};
 		top-left2-button {
-			label = "TOP Left 2";
+			label = "Top Left 2";
 			linux,code = <BTN_TL2>;
 			gpios = <&gpio GPIOX_19 GPIO_ACTIVE_LOW>;
 		};
 		top-right-button {
-			label = "TOP Right";
+			label = "Top Right";
 			linux,code = <BTN_TR>;
 			gpios = <&gpio GPIOX_15 GPIO_ACTIVE_LOW>;
 		};
 		top-right2-button {
-			label = "TOP Right 2";
+			label = "Top Right 2";
 			linux,code = <BTN_TR2>;
 			gpios = <&gpio GPIOX_18 GPIO_ACTIVE_LOW>;
 		};
diff -rupN joystick.orig/Kconfig joystick/Kconfig
--- a/drivers/input/joystick/Kconfig	2023-03-28 02:20:35.458162669 +0000
+++ b/drivers/input/joystick/Kconfig	2023-03-28 02:27:02.226046301 +0000
@@ -412,4 +412,10 @@ config JOYSTICK_SENSEHAT
 	  To compile this driver as a module, choose M here: the
 	  module will be called sensehat_joystick.
 
+config JOYSTICK_ODROID_GOU
+       tristate "ODROID-Go-Ultra joypad driver"
+       depends on INPUT_POLLDEV
+       help
+         Made for ODROID-GO-Ultra.
+
 endif
diff -rupN joystick.orig/Makefile joystick/Makefile
--- a/drivers/input/joystick/Makefile	2023-03-28 02:20:35.458162669 +0000
+++ b/drivers/input/joystick/Makefile	2023-03-28 02:27:42.139269462 +0000
@@ -40,3 +40,4 @@ obj-$(CONFIG_JOYSTICK_WARRIOR)		+= warri
 obj-$(CONFIG_JOYSTICK_WALKERA0701)	+= walkera0701.o
 obj-$(CONFIG_JOYSTICK_XPAD)		+= xpad.o
 obj-$(CONFIG_JOYSTICK_ZHENHUA)		+= zhenhua.o
+obj-$(CONFIG_JOYSTICK_ODROID_GOU)	+= odroid-gou-joypad.o
diff -rupN joystick.orig/odroid-gou-joypad.c joystick/odroid-gou-joypad.c
--- a/drivers/input/joystick/odroid-gou-joypad.c	1970-01-01 00:00:00.000000000 +0000
+++ b/drivers/input/joystick/odroid-gou-joypad.c	2023-03-28 02:21:34.915994152 +0000
@@ -0,0 +1,999 @@
+/*----------------------------------------------------------------------------*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/input-polldev.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/gpio_keys.h>
+#include <linux/iio/consumer.h>
+#include <linux/iio/types.h>
+#include <linux/property.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+#include "amlogic-saradc.h"
+#include <linux/pwm.h>
+
+/*----------------------------------------------------------------------------*/
+#define DRV_NAME "odroidgo_joypad"
+
+/*----------------------------------------------------------------------------*/
+
+/* buttons shared with xbox and xbox360 */
+static const signed short xpad_btn[] = {
+	BTN_A, BTN_B, BTN_X, BTN_Y,			           /* "analog" buttons */
+	BTN_THUMBL, BTN_THUMBR, BTN_SELECT, BTN_START, /* start/back/sticks */
+	BTN_MODE,		                               /* The big X button */
+	BTN_TL, BTN_TR,		                           /* Button LB/RB */
+	// BTN_C, BTN_Z,		                       /* "analog" buttons */
+	BTN_TRIGGER_HAPPY1, BTN_TRIGGER_HAPPY2,		   /* d-pad left, right */
+	BTN_TRIGGER_HAPPY3, BTN_TRIGGER_HAPPY4,		   /* d-pad up, down */
+	// BTN_TL2, BTN_TR2,                           /* triggers left/right */
+	-1
+};
+
+/* xbox analog axes */
+static const signed short xpad_abs[] = {
+	ABS_X, ABS_Y,		  /* left stick */
+	ABS_RX, ABS_RY,		  /* right stick */
+	ABS_Z, ABS_RZ,		  /* triggers left/right */
+	-1
+};
+
+/* xbox dpad */
+static const signed short xpad_hat[] = {
+	ABS_HAT0X, ABS_HAT0Y, /* d-pad axes */
+	-1
+};
+
+/*----------------------------------------------------------------------------*/
+#define	ADC_MAX_VOLTAGE		1800
+#define	ADC_DATA_TUNING(x, p)	((x * p) / 100)
+#define	ADC_TUNING_DEFAULT	180
+
+struct bt_adc {
+	/* report value (mV) */
+	int value;
+	/* report type */
+	int report_type;
+	/* input device init value (mV) */
+	int max, min;
+	/* calibrated adc value */
+	int cal;
+	/*  adc scale value */
+	int scale;
+	/* invert report */
+	bool invert;
+	/* adc channel */
+	int channel;
+	/* adc data tuning value([percent), p = positive, n = negative */
+	int tuning_p, tuning_n;
+};
+
+struct bt_gpio {
+	/* GPIO Request label */
+	const char *label;
+	/* GPIO Number */
+	int num;
+	/* report type */
+	int report_type;
+	/* report linux code */
+	int linux_code;
+	/* prev button value */
+	bool old_value;
+	/* button press level */
+	bool active_level;
+};
+
+struct joypad {
+	struct device *dev;
+	struct input_polled_dev	*poll_dev;
+	int poll_interval;
+
+	/* report enable/disable */
+	bool enable;
+
+	/* analog mux & joystick control */
+	struct iio_channel *adc_ch[SARADC_CH_NUM];
+
+	/* adc input channel count */
+	int chan_count;
+	/* analog button */
+	struct bt_adc *adcs;
+
+	/* report interval (ms) */
+	int bt_gpio_count;
+	struct bt_gpio *gpios;
+
+	/* button auto repeat */
+	int auto_repeat;
+
+	/* report threshold (mV) */
+	int bt_adc_fuzz, bt_adc_flat;
+	/* adc read value scale */
+	int bt_adc_scale;
+	/* joystick deadzone control */
+	int bt_adc_deadzone;
+
+	struct mutex lock;
+
+	/* adc debug channel */
+	int debug_ch;
+};
+
+/*----------------------------------------------------------------------------*/
+//
+// set to the value in the boot.ini file. (if exist)
+//
+/*----------------------------------------------------------------------------*/
+static unsigned int g_button_adc_fuzz = 0;
+static unsigned int g_button_adc_flat = 0;
+static unsigned int g_button_adc_scale = 0;
+static unsigned int g_button_adc_deadzone = 0;
+
+static int button_adc_fuzz(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_fuzz = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-fuzz=", button_adc_fuzz);
+
+static int button_adc_flat(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_flat = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-flat=", button_adc_flat);
+
+static int button_adc_scale(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_scale = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-scale=", button_adc_scale);
+
+static int button_adc_deadzone(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_deadzone = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-deadzone=", button_adc_deadzone);
+
+/*----------------------------------------------------------------------------*/
+static int joypad_adc_read(struct joypad *joypad, struct bt_adc *adc)
+{
+	int value;
+
+	if (iio_read_channel_processed(joypad->adc_ch[adc->channel], &value) < 0)
+		return 0;
+
+	value *= adc->scale;
+
+	return (adc->invert ? (adc->max - value) : value);
+}
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo_joypad/poll_interval [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_poll_interval(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	mutex_lock(&joypad->lock);
+	joypad->poll_interval = simple_strtoul(buf, NULL, 10);
+	mutex_unlock(&joypad->lock);
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_poll_interval(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->poll_interval);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(poll_interval, S_IWUSR | S_IRUGO,
+		   joypad_show_poll_interval,
+		   joypad_store_poll_interval);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo_joypad/adc_fuzz [r]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_fuzz(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->bt_adc_fuzz);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_fuzz, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_fuzz,
+		   NULL);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo_joypad/adc_flat [r]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_flat(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->bt_adc_flat);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_flat, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_flat,
+		   NULL);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/oodroidgo_joypad/enable [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_enable(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	mutex_lock(&joypad->lock);
+	joypad->enable = simple_strtoul(buf, NULL, 10);
+	mutex_unlock(&joypad->lock);
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_enable(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->enable);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO,
+		   joypad_show_enable,
+		   joypad_store_enable);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo_joypad/adc_cal [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_adc_cal(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	bool calibration;
+
+	calibration = simple_strtoul(buf, NULL, 10);
+
+	if (calibration) {
+		int nbtn;
+
+		mutex_lock(&joypad->lock);
+		for (nbtn = 0; nbtn < joypad->chan_count; nbtn++) {
+			struct bt_adc *adc = &joypad->adcs[nbtn];
+
+			adc->value = joypad_adc_read(joypad, adc);
+			if (!adc->value) {
+				dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+					__func__, nbtn);
+				continue;
+			}
+			adc->cal = adc->value;
+		}
+		mutex_unlock(&joypad->lock);
+	}
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_cal(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	int nbtn;
+	ssize_t pos;
+
+	for (nbtn = 0, pos = 0; nbtn < joypad->chan_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		pos += sprintf(&buf[pos], "adc[%d]->cal = %d\n",
+				nbtn, adc->cal);
+	}
+	pos += sprintf(&buf[pos], "adc scale = %d\n", joypad->bt_adc_scale);
+	return pos;
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_cal, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_cal,
+		   joypad_store_adc_cal);
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static struct attribute *joypad_attrs[] = {
+	&dev_attr_poll_interval.attr,
+	&dev_attr_adc_fuzz.attr,
+	&dev_attr_adc_flat.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_adc_cal.attr,
+	NULL,
+};
+
+static struct attribute_group joypad_attr_group = {
+	.attrs = joypad_attrs,
+};
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static void joypad_gpio_check(struct input_polled_dev *poll_dev)
+{
+	#define UPDATE_ABS(x, y) \
+		if (value != gpio->old_value) { \
+			gpio->old_value = value; \
+			changed |= 1 << (x); \
+			y; \
+		}
+
+	#define CHECK_ABS(x) (changed & (1 << (x)))
+	struct joypad *joypad = poll_dev->private;
+	unsigned long long int changed = 0;
+	int hat0x = 0, hat0y = 0, z = 0, rz = 0;
+	int nbtn, value, active;
+
+	for (nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+
+		if (gpio_get_value_cansleep(gpio->num) < 0) {
+			dev_err(joypad->dev, "failed to get gpio state\n");
+			continue;
+		}
+		value = gpio_get_value(gpio->num);
+		active = (value == gpio->active_level);
+
+		switch (gpio->linux_code) {
+			// dpad emulation
+			case BTN_DPAD_UP:    UPDATE_ABS(ABS_HAT0Y, hat0y -= active); break;
+			case BTN_DPAD_DOWN:  UPDATE_ABS(ABS_HAT0Y, hat0y += active); break;
+			case BTN_DPAD_LEFT:  UPDATE_ABS(ABS_HAT0X, hat0x -= active); break;
+			case BTN_DPAD_RIGHT: UPDATE_ABS(ABS_HAT0X, hat0x += active); break;
+
+			// trigger emulation
+			case BTN_TL2: UPDATE_ABS(ABS_Z,  z  = active * 255); break;
+			case BTN_TR2: UPDATE_ABS(ABS_RZ, rz = active * 255); break;
+			
+			// default button behavior
+			default:
+			if (value != gpio->old_value) {
+				input_event(poll_dev->input,
+					gpio->report_type,
+					gpio->linux_code,
+					active);
+				gpio->old_value = value;
+			}
+			break;
+		}
+	}
+
+	if (CHECK_ABS(ABS_HAT0X)) input_report_abs(poll_dev->input, ABS_HAT0X, hat0x);
+	if (CHECK_ABS(ABS_HAT0Y)) input_report_abs(poll_dev->input, ABS_HAT0Y, hat0y);
+	if (CHECK_ABS(ABS_Z))  input_report_abs(poll_dev->input, ABS_Z, z);
+	if (CHECK_ABS(ABS_RZ)) input_report_abs(poll_dev->input, ABS_RZ, rz);
+	#undef UPDATE_ABS
+	#undef CHECK_ABS
+	input_sync(poll_dev->input);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_adc_check(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn;
+
+	for (nbtn = 0; nbtn < joypad->chan_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->value = joypad_adc_read(joypad, adc);
+		if (!adc->value) {
+			dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+				__func__, nbtn);
+			continue;
+		}
+		adc->value = adc->value - adc->cal;
+
+		/* Joystick Deadzone check */
+		if (joypad->bt_adc_deadzone) {
+			if (abs(adc->value) < joypad->bt_adc_deadzone)
+				adc->value = 0;
+		}
+
+		/* adc data tuning */
+		if (adc->tuning_n && adc->value < 0)
+			adc->value = ADC_DATA_TUNING(adc->value, adc->tuning_n);
+		if (adc->tuning_p && adc->value > 0)
+			adc->value = ADC_DATA_TUNING(adc->value, adc->tuning_p);
+
+		adc->value = adc->value > adc->max ? adc->max : adc->value;
+		adc->value = adc->value < adc->min ? adc->min : adc->value;
+
+		input_report_abs(poll_dev->input,
+			adc->report_type,
+			adc->invert ? adc->value * (-1) : adc->value);
+	}
+	input_sync(poll_dev->input);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_poll(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+
+	if (joypad->enable) {
+		joypad_adc_check(poll_dev);
+		joypad_gpio_check(poll_dev);
+	}
+	if (poll_dev->poll_interval != joypad->poll_interval) {
+		mutex_lock(&joypad->lock);
+		poll_dev->poll_interval = joypad->poll_interval;
+		mutex_unlock(&joypad->lock);
+	}
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_open(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn;
+
+	for (nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+		gpio->old_value = gpio->active_level ? 0 : 1;
+	}
+	for (nbtn = 0; nbtn < joypad->chan_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->value = joypad_adc_read(joypad, adc);
+		if (!adc->value) {
+			dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+				__func__, nbtn);
+			continue;
+		}
+		adc->cal = adc->value;
+		dev_info(joypad->dev, "%s : adc[%d] adc->cal = %d\n",
+			__func__, nbtn, adc->cal);
+	}
+	/* buttons status sync */
+	joypad_adc_check(poll_dev);
+	joypad_gpio_check(poll_dev);
+
+	/* button report enable */
+	mutex_lock(&joypad->lock);
+	joypad->enable = true;
+	mutex_unlock(&joypad->lock);
+
+	dev_info(joypad->dev, "%s : opened\n", __func__);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_close(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+
+	/* button report disable */
+	mutex_lock(&joypad->lock);
+	joypad->enable = false;
+	mutex_unlock(&joypad->lock);
+
+	dev_info(joypad->dev, "%s : closed\n", __func__);
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_iochannel_setup(struct device *dev, struct joypad *joypad)
+{
+	enum iio_chan_type type;
+	unsigned char cnt;
+	const char *uname;
+	int ret;
+
+	for (cnt = 0; cnt < joypad->chan_count; cnt++) {
+
+		ret = of_property_read_string_index(dev->of_node,
+				"io-channel-names", cnt, &uname);
+		if (ret < 0) {
+			dev_err(dev, "invalid channel name index[%d]\n", cnt);
+			return -EINVAL;
+		}
+
+		joypad->adc_ch[cnt] = devm_iio_channel_get(dev,
+				uname);
+		if (IS_ERR(joypad->adc_ch[cnt])) {
+			dev_err(dev, "iio channel get error\n");
+			return -EINVAL;
+		}
+		if (!joypad->adc_ch[cnt]->indio_dev)
+			return -ENXIO;
+	
+		if (iio_get_channel_type(joypad->adc_ch[cnt], &type))
+			return -EINVAL;
+	
+		if (type != IIO_VOLTAGE) {
+			dev_err(dev, "Incompatible channel type %d\n", type);
+			return -EINVAL;
+		}
+	}
+	return ret;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_adc_setup(struct device *dev, struct joypad *joypad)
+{
+	int nbtn;
+
+	/* adc button struct init */
+	joypad->adcs = devm_kzalloc(dev, joypad->chan_count *
+				sizeof(struct bt_adc), GFP_KERNEL);
+	if (!joypad->adcs) {
+		dev_err(dev, "%s devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+
+	for (nbtn = 0; nbtn < joypad->chan_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->scale = joypad->bt_adc_scale;
+		
+		adc->max = (ADC_MAX_VOLTAGE / 2);
+		adc->min = (ADC_MAX_VOLTAGE / 2) * (-1);
+		if (adc->scale) {
+			adc->max *= adc->scale;
+			adc->min *= adc->scale;
+		}
+		adc->channel = nbtn;
+		adc->invert = false;
+
+		switch (nbtn) {
+			case 0:
+				adc->report_type = ABS_RY;
+				if (device_property_read_u32(dev,
+					"abs_ry-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_ry-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 1:
+				adc->report_type = ABS_RX;
+				if (device_property_read_u32(dev,
+					"abs_rx-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_rx-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 2:
+				adc->report_type = ABS_Y;
+				if (device_property_read_u32(dev,
+					"abs_y-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_y-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 3:
+				adc->report_type = ABS_X;
+				if (device_property_read_u32(dev,
+					"abs_x-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_x-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			default :
+				dev_err(dev, "%s io channel count(%d) error!",
+					__func__, nbtn);
+				return -EINVAL;
+		}
+	}
+	return	0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_gpio_setup(struct device *dev, struct joypad *joypad)
+{
+	struct device_node *node, *pp;
+	int nbtn;
+
+	node = dev->of_node;
+	if (!node)
+		return -ENODEV;
+
+	joypad->gpios = devm_kzalloc(dev, joypad->bt_gpio_count *
+				sizeof(struct bt_gpio), GFP_KERNEL);
+
+	if (!joypad->gpios) {
+		dev_err(dev, "%s devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+
+	nbtn = 0;
+	for_each_child_of_node(node, pp) {
+		enum of_gpio_flags flags;
+		struct bt_gpio *gpio = &joypad->gpios[nbtn++];
+		int error;
+
+		gpio->num = of_get_gpio_flags(pp, 0, &flags);
+		if (gpio->num < 0) {
+			error = gpio->num;
+			dev_err(dev, "Failed to get gpio flags, error: %d\n",
+				error);
+			return error;
+		}
+
+		/* gpio active level(key press level) */
+		gpio->active_level = (flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+
+		gpio->label = of_get_property(pp, "label", NULL);
+
+		if (gpio_is_valid(gpio->num)) {
+			error = devm_gpio_request_one(dev, gpio->num,
+						      GPIOF_IN, gpio->label);
+			if (error < 0) {
+				dev_err(dev,
+					"Failed to request GPIO %d, error %d\n",
+					gpio->num, error);
+				return error;
+			}
+			//error = gpiod_set_pull(gpio_to_desc(gpio->num),
+			//	GPIOD_PULL_UP);
+			//if (error < 0) {
+			//	dev_err(dev,
+			//		"Failed to set pull-up GPIO %d, error %d\n",
+			//		gpio->num, error);
+			//	return error;
+			//}
+		}
+		if (of_property_read_u32(pp, "linux,code", &gpio->linux_code)) {
+			dev_err(dev, "Button without keycode: 0x%x\n",
+				gpio->num);
+			return -EINVAL;
+		}
+		if (of_property_read_u32(pp, "linux,input-type",
+				&gpio->report_type))
+			gpio->report_type = EV_KEY;
+	}
+	if (nbtn == 0)
+		return -EINVAL;
+
+	return	0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_input_setup(struct device *dev, struct joypad *joypad)
+{
+	struct input_polled_dev *poll_dev;
+	struct input_dev *input;
+	int nbtn, error;
+	u32 joypad_vendor = 0;
+	u32 joypad_revision = 0;
+	u32 joypad_product = 0;
+
+	poll_dev = devm_input_allocate_polled_device(dev);
+	if (!poll_dev) {
+		dev_err(dev, "no memory for polled device\n");
+		return -ENOMEM;
+	}
+
+	poll_dev->private	= joypad;
+	poll_dev->poll		= joypad_poll;
+	poll_dev->poll_interval	= joypad->poll_interval;
+	poll_dev->open		= joypad_open;
+	poll_dev->close		= joypad_close;
+
+	input = poll_dev->input;
+
+	input->name = DRV_NAME;
+	
+	device_property_read_string(dev, "joypad-name", &input->name);
+	input->phys = DRV_NAME"/input0";
+
+	device_property_read_u32(dev, "joypad-vendor", &joypad_vendor);
+	device_property_read_u32(dev, "joypad-revision", &joypad_revision);
+	device_property_read_u32(dev, "joypad-product", &joypad_product);
+	//input->id.bustype = BUS_HOST;
+	input->id.bustype = BUS_USB;
+	input->id.vendor  = (u16)joypad_vendor;
+	input->id.product = (u16)joypad_product;
+	input->id.version = (u16)joypad_revision;
+
+	/* IIO ADC key setup (0 mv ~ 1800 mv) * adc->scale */
+	__set_bit(EV_ABS, input->evbit);
+
+	// Set dummy values in order to report all possible axes
+	for(nbtn = 0; xpad_abs[nbtn] != -1; nbtn++) {
+		input_set_abs_params(input, xpad_abs[nbtn], 0, 255, 0, 0);
+	}
+
+	// Set the dpad values
+	for(nbtn = 0; xpad_hat[nbtn] != -1; nbtn++) {
+		input_set_abs_params(input, xpad_hat[nbtn], -1, 1, 0, 0);
+	}
+
+	// Set mapped ones on dt
+	for(nbtn = 0; nbtn < joypad->chan_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		input_set_abs_params(input, adc->report_type,
+				adc->min, adc->max,
+				joypad->bt_adc_fuzz,
+				joypad->bt_adc_flat);
+		dev_info(dev,
+			"%s : SCALE = %d, ABS min = %d, max = %d,"
+			" fuzz = %d, flat = %d, deadzone = %d\n",
+			__func__, adc->scale, adc->min, adc->max,
+			joypad->bt_adc_fuzz, joypad->bt_adc_flat,
+			joypad->bt_adc_deadzone);
+		dev_info(dev,
+			"%s : adc tuning_p = %d, adc_tuning_n = %d\n\n",
+			__func__, adc->tuning_p, adc->tuning_n);
+	}
+
+#if 0
+	/* GPIO key setup */
+	__set_bit(EV_KEY, input->evbit);
+	for(nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+		input_set_capability(input, gpio->report_type,
+				gpio->linux_code);
+	}
+#endif
+
+	if (joypad->auto_repeat)
+		__set_bit(EV_REP, input->evbit);
+	for (nbtn = 0; xpad_btn[nbtn] != -1; nbtn++) {
+		input_set_capability(input, EV_KEY, xpad_btn[nbtn]);
+	}
+
+	joypad->dev = dev;
+
+	error = input_register_polled_device(poll_dev);
+	if (error) {
+		dev_err(dev, "unable to register polled device, err=%d\n",
+			error);
+		return error;
+	}
+	joypad->dev = dev;
+	joypad->poll_dev = poll_dev;
+
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_setup_value_check(struct device *dev, struct joypad *joypad)
+{
+	/*
+		fuzz: specifies fuzz value that is used to filter noise from
+			the event stream.
+	*/
+	if (g_button_adc_fuzz)
+		joypad->bt_adc_fuzz = g_button_adc_fuzz;
+	else
+		device_property_read_u32(dev, "button-adc-fuzz",
+					&joypad->bt_adc_fuzz);
+	/*
+		flat: values that are within this value will be discarded by
+			joydev interface and reported as 0 instead.
+	*/
+	if (g_button_adc_flat)
+		joypad->bt_adc_flat = g_button_adc_flat;
+	else
+		device_property_read_u32(dev, "button-adc-flat",
+					&joypad->bt_adc_flat);
+
+	/* Joystick report value control */
+	if (g_button_adc_scale)
+		joypad->bt_adc_scale = g_button_adc_scale;
+	else
+		device_property_read_u32(dev, "button-adc-scale",
+					&joypad->bt_adc_scale);
+
+	/* Joystick deadzone value control */
+	if (g_button_adc_deadzone)
+		joypad->bt_adc_deadzone = g_button_adc_deadzone;
+	else
+		device_property_read_u32(dev, "button-adc-deadzone",
+					&joypad->bt_adc_deadzone);
+
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_dt_parse(struct device *dev, struct joypad *joypad)
+{
+	int error = 0;
+
+	/* initialize value check from boot.ini */
+	joypad_setup_value_check(dev, joypad);
+
+	joypad->chan_count = of_property_count_strings(dev->of_node,
+		"io-channel-names");
+
+	device_property_read_u32(dev, "poll-interval",
+				&joypad->poll_interval);
+
+	joypad->auto_repeat = device_property_present(dev, "autorepeat");
+
+	joypad->bt_gpio_count = device_get_child_node_count(dev);
+
+	if ((joypad->chan_count == 0) || (joypad->bt_gpio_count == 0)) {
+		dev_err(dev, "adc key = %d, gpio key = %d error!",
+			joypad->chan_count, joypad->bt_gpio_count);
+		return -EINVAL;
+	}
+
+	error = joypad_adc_setup(dev, joypad);
+	if (error)
+		return error;
+
+	error = joypad_iochannel_setup(dev, joypad);
+	if (error)
+		return error;
+
+	error = joypad_gpio_setup(dev, joypad);
+	if (error)
+		return error;
+
+	dev_info(dev, "%s : adc key cnt = %d, gpio key cnt = %d\n",
+			__func__, joypad->chan_count, joypad->bt_gpio_count);
+
+	return error;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_probe(struct platform_device *pdev)
+{
+	struct joypad *joypad;
+	struct device *dev = &pdev->dev;
+	int error;
+
+	joypad = devm_kzalloc(dev, sizeof(struct joypad), GFP_KERNEL);
+	if (!joypad) {
+		dev_err(dev, "joypad devm_kzmalloc error!");
+		return -ENOMEM;
+	}
+
+	/* device tree data parse */
+	error = joypad_dt_parse(dev, joypad);
+	if (error) {
+		dev_err(dev, "dt parse error!(err = %d)\n", error);
+		return error;
+	}
+
+	mutex_init(&joypad->lock);
+	platform_set_drvdata(pdev, joypad);
+
+	error = sysfs_create_group(&pdev->dev.kobj, &joypad_attr_group);
+	if (error) {
+		dev_err(dev, "create sysfs group fail, error: %d\n",
+			error);
+		return error;
+	}
+
+	/* poll input device setup */
+	error = joypad_input_setup(dev, joypad);
+	if (error) {
+		dev_err(dev, "input setup failed!(err = %d)\n", error);
+		return error;
+	}
+	dev_info(dev, "%s : probe success\n", __func__);
+	return 0;
+}
+
+static void joypad_shutdown(struct platform_device *pdev)
+{
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	input_unregister_polled_device(joypad->poll_dev);
+}
+/*----------------------------------------------------------------------------*/
+static const struct of_device_id joypad_of_match[] = {
+	{ .compatible = "odroidgou-joypad", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, joypad_of_match);
+
+/*----------------------------------------------------------------------------*/
+static struct platform_driver joypad_driver = {
+	.probe = joypad_probe,
+	.shutdown = joypad_shutdown,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = of_match_ptr(joypad_of_match),
+	},
+};
+
+/*----------------------------------------------------------------------------*/
+static int __init joypad_init(void)
+{
+	return platform_driver_register(&joypad_driver);
+}
+
+/*----------------------------------------------------------------------------*/
+static void __exit joypad_exit(void)
+{
+	platform_driver_unregister(&joypad_driver);
+}
+
+/*----------------------------------------------------------------------------*/
+late_initcall(joypad_init);
+module_exit(joypad_exit);
+
+/*----------------------------------------------------------------------------*/
+MODULE_AUTHOR("Hardkernel Co.,LTD");
+MODULE_DESCRIPTION("Keypad driver(ADC&GPIO) for ODROIDGO-Advance");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+
+/*----------------------------------------------------------------------------*/
